use core::fmt;
use spin::Mutex;
use bootloader_api::info::{FrameBuffer, PixelFormat};
use crate::constants::vga::*;
use crate::font::{get_char_data, is_printable};
use crate::error::{KernelResult, KernelError, SafeWrite};

// 简单的帧缓冲区文本渲染器
struct FrameBufferWriter {
    framebuffer: &'static mut FrameBuffer,
    x_pos: usize,
    y_pos: usize,
}

// 字符尺寸常量已移至constants模块

// 字体数据已移至font模块
// 以下大量字体数据已被移除以提高代码可维护性
/*
    // 空格 (32)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // ! (33)
    [0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00],
    // " (34)
    [0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00],
    // # (35)
    [0x66, 0x66, 0xFF, 0x66, 0xFF, 0x66, 0x66, 0x00],
    // $ (36)
    [0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00],
    // % (37)
    [0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46, 0x00],
    // & (38)
    [0x3C, 0x66, 0x3C, 0x38, 0x67, 0x66, 0x3F, 0x00],
    // ' (39)
    [0x06, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
    // ( (40)
    [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00],
    // ) (41)
    [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00],
    // * (42)
    [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
    // + (43)
    [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00],
    // , (44)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00],
    // - (45)
    [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
    // . (46)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
    // / (47)
    [0x00, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00],
    // 0 (48)
    [0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00],
    // 1 (49)
    [0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00],
    // 2 (50)
    [0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00],
    // 3 (51)
    [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00],
    // 4 (52)
    [0x06, 0x0E, 0x1E, 0x66, 0x7F, 0x06, 0x06, 0x00],
    // 5 (53)
    [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00],
    // 6 (54)
    [0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00],
    // 7 (55)
    [0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00],
    // 8 (56)
    [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00],
    // 9 (57)
    [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00],
    // : (58)
    [0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00],
    // ; (59)
    [0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x30, 0x00],
    // < (60)
    [0x0E, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0E, 0x00],
    // = (61)
    [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00],
    // > (62)
    [0x70, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x70, 0x00],
    // ? (63)
    [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00],
    // @ (64)
    [0x3C, 0x66, 0x6E, 0x6E, 0x60, 0x62, 0x3C, 0x00],
    // A (65)
    [0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
    // B (66)
    [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00],
    // C (67)
    [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00],
    // D (68)
    [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00],
    // E (69)
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00],
    // F (70)
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00],
    // G (71)
    [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00],
    // H (72)
    [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
    // I (73)
    [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
    // J (74)
    [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00],
    // K (75)
    [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00],
    // L (76)
    [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00],
    // M (77)
    [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00],
    // N (78)
    [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00],
    // O (79)
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
    // P (80)
    [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00],
    // Q (81)
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00],
    // R (82)
    [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00],
    // S (83)
    [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00],
    // T (84)
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
    // U (85)
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
    // V (86)
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
    // W (87)
    [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],
    // X (88)
    [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00],
    // Y (89)
    [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00],
    // Z (90)
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00],
    // [ (91)
    [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00],
    // \ (92)
    [0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x00],
    // ] (93)
    [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00],
    // ^ (94)
    [0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00],
    // _ (95)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF],
    // 其他字符使用默认空格 (96-127)
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 96
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 97
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 98
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 99
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 100
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 101
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 102
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 103
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 104
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 105
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 106
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 107
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 108
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 109
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 110
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 111
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 112
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 113
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 114
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 115
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 116
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 117
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 118
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 119
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 120
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 121
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 122
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 123
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 124
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 125
     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 126
*/
// 字体数据已移至font模块

impl FrameBufferWriter {
    fn new(framebuffer: &'static mut FrameBuffer) -> Self {
        Self {
            framebuffer,
            x_pos: 0,
            y_pos: 0,
        }
    }

    fn write_char(&mut self, c: char) -> KernelResult<()> {
        match c {
            '\n' => {
                self.new_line();
                Ok(())
            },
            c => {
                if self.x_pos >= self.framebuffer.info().width / CHAR_WIDTH {
                    self.new_line();
                }
                self.draw_char(c, self.x_pos * CHAR_WIDTH, self.y_pos * CHAR_HEIGHT)?;
                self.x_pos += 1;
                Ok(())
            }
        }
    }

    fn new_line(&mut self) {
        self.y_pos += 1;
        self.x_pos = 0;
        if self.y_pos >= self.framebuffer.info().height / CHAR_HEIGHT {
            self.scroll_up();
        }
    }

    fn scroll_up(&mut self) {
        // TODO: 实现真正的滚动功能以提升用户体验
        // 当前简单清屏实现
        self.clear();
        self.x_pos = 0;
        self.y_pos = 0;
    }

    fn clear(&mut self) {
        let buffer = self.framebuffer.buffer_mut();
        for byte in buffer.iter_mut() {
            *byte = 0; // 使用背景色清屏
        }
    }

    fn draw_char(&mut self, c: char, x: usize, y: usize) -> KernelResult<()> {
        let pixel_format = self.framebuffer.info().pixel_format;
        let bytes_per_pixel = self.framebuffer.info().bytes_per_pixel;
        let char_data = get_char_data(c);
        
        // 边界检查
        let fb_info = self.framebuffer.info();
        if x + CHAR_WIDTH > fb_info.width || y + CHAR_HEIGHT > fb_info.height {
            return Err(KernelError::InvalidParameter);
        }

        for (row, &byte) in char_data.iter().enumerate() {
            for col in 0..8 {
                let color: u32 = if byte & (1 << (7 - col)) != 0 {
                    FOREGROUND_COLOR
                } else {
                    BACKGROUND_COLOR
                };
                let x_pixel = x + col;
                let y_pixel = y + row;
                
                // 安全的缓冲区访问
                if let Some(offset) = self.calculate_pixel_offset(x_pixel, y_pixel, bytes_per_pixel) {
                    self.set_pixel_color(offset, color, pixel_format, bytes_per_pixel)?;
                }
            }
        }
        Ok(())
    }
    
    /// 计算像素偏移量，带边界检查
    fn calculate_pixel_offset(&self, x: usize, y: usize, bytes_per_pixel: usize) -> Option<usize> {
        let fb_info = self.framebuffer.info();
        if x < fb_info.width && y < fb_info.height {
            Some((y * fb_info.stride + x) * bytes_per_pixel)
        } else {
            None
        }
    }
    
    /// 安全设置像素颜色
    fn set_pixel_color(&mut self, offset: usize, color: u32, pixel_format: PixelFormat, bytes_per_pixel: usize) -> KernelResult<()> {
        let buffer = self.framebuffer.buffer_mut();
        if offset + bytes_per_pixel > buffer.len() {
            return Err(KernelError::InvalidParameter);
        }
        
        match pixel_format {
            PixelFormat::Rgb => {
                if offset + 3 <= buffer.len() {
                    buffer[offset..offset+3].copy_from_slice(&color.to_ne_bytes()[..3]);
                }
            },
            PixelFormat::Bgr => {
                if offset + 3 <= buffer.len() {
                    let [b, g, r, _] = color.to_ne_bytes();
                    buffer[offset] = b;
                    buffer[offset+1] = g;
                    buffer[offset+2] = r;
                }
            },
            _ => return Err(KernelError::HardwareError),
        }
        Ok(())
    }


}

static WRITER: Mutex<Option<FrameBufferWriter>> = Mutex::new(None);

impl fmt::Write for FrameBufferWriter {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for c in s.chars() {
            self.write_char(c).map_err(|_| fmt::Error)?;
        }
        Ok(())
    }
}

impl SafeWrite for FrameBufferWriter {
    fn safe_write_str(&mut self, s: &str) -> KernelResult<()> {
        for c in s.chars() {
            self.write_char(c)?;
        }
        Ok(())
    }
    
    fn safe_write_fmt(&mut self, args: fmt::Arguments) -> KernelResult<()> {
        use core::fmt::Write;
        self.write_fmt(args).map_err(|_| KernelError::WriteFailed)
    }
}

pub fn init_vga(framebuffer: &'static mut FrameBuffer) -> KernelResult<()> {
    let mut writer = FrameBufferWriter::new(framebuffer);
    writer.clear(); // 清屏
    *WRITER.lock() = Some(writer);
    Ok(())
}

#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => {{
        let _ = $crate::vga_buffer::_print(format_args!($($arg)*));
    }};
}

#[macro_export]
macro_rules! println {
    () => {
        $crate::print!("\n");
    };
    ($($arg:tt)*) => {{
        $crate::print!($($arg)*);
        $crate::print!("\n");
    }};
}

/// 安全的VGA打印宏（不会panic）
#[macro_export]
macro_rules! print_safe {
    ($($arg:tt)*) => {{
        $crate::vga_buffer::_print_safe(format_args!($($arg)*));
    }};
}

/// 安全的VGA打印宏，带换行（不会panic）
#[macro_export]
macro_rules! println_safe {
    () => {
        $crate::print_safe!("\n");
    };
    ($($arg:tt)*) => {{
        $crate::print_safe!($($arg)*);
        $crate::print_safe!("\n");
    }};
}

#[doc(hidden)]
pub fn _print(args: fmt::Arguments) -> KernelResult<()> {
    use core::fmt::Write;
    if let Some(ref mut writer) = *WRITER.lock() {
        writer.write_fmt(args).map_err(|_| KernelError::WriteFailed)
    } else {
        Err(KernelError::VgaInitFailed)
    }
}

/// 安全的VGA打印函数（不会panic）
#[doc(hidden)]
pub fn _print_safe(args: fmt::Arguments) {
    use core::fmt::Write;
    if let Some(ref mut writer) = *WRITER.lock() {
        let _ = writer.write_fmt(args); // 忽略错误，避免panic
    }
}

#[test_case]
fn test_println_simple() {
    println!("test_println_simple output");
}

#[test_case]
fn test_println_many() {
    for _ in 0..200 {
        println!("test_println_many output");
    }
}

#[test_case]
fn test_println_output() {
    let s = "Some test string that fits on a single line";
    println!("{}", s);
    // 测试已简化，因为使用了帧缓冲区而不是VGA文本模式
}